/*!
 * Raita top-level namespace.
 *
 * @copyright 2015 Dan Duvall <dduvall@wikimedia.org> + contributors
 */
(function (binding, factory) {
	'use strict';

	if (typeof define === 'function' && define.amd) {
		define('raita', ['riot', 'jquery'], factory);
	} else {
		binding.raita = factory(binding.riot, binding.jQuery);
	}
})(this, function (riot, $) {
	'use strict';

	/**
	 * @class
	 * @singleton
	 *
	 * Raita provides a dashboard for visualizing Cucumber test results and
	 * diagnosing step failure. It relies on an Elasticsearch index containing
	 * structured logs generated by MediaWiki-Selenium.
	 */
	var raita = {};

	/**
	 * @property
	 * Default query object that sets a high upper limit for the number of
	 * returned documents.
	 */
	raita.DEFAULT_QUERY = { size: 1000 };

	/**
	 * @property
	 * Raita's current version number.
	 */
	raita.VERSION = '0.0.0';

	/**
	 * @property
	 * Cucumber status to Bootstrap label mapping.
	 */
	raita.statuses = { 'passed': 'success', 'skipped': 'warning', 'failed': 'danger' };

	/**
	 * Helper for bubbling Riot events upward from nested tags.
	 *
	 * @param {riot.Tag} tag Tag object
	 * @param {String} nested Name of nested tag(s) from which to bubble events.
	 * @param {String} event Name of event to bubble.
	 */
	raita.bubble = function (tag, nested, event) {
		var nestedTag = tag.tags[nested];

		function relayFrom(ntag) {
			ntag.on(event, function () {
				tag.trigger.apply(tag, Array.prototype.concat.apply([event], arguments));
			});
		}

		if (typeof nestedTag === 'undefined') {
			return;
		} else if (nestedTag instanceof Array) {
			for (var i = 0; i < nestedTag.length; i++) {
				relayFrom(nestedTag[i]);
			}
		} else {
			relayFrom(nestedTag);
		}
	};

	/**
	 * Sets up the main dashboard UI component and a router that responds to URL
	 * fragment changes.
	 *
	 * The element resolved by the given selector will be mounted as an
	 * `rt-dashboard` tag.
	 *
	 * @param {String} selector Selector for resolving root dashboard element.
	 * @param {String} dbURL URL to the Elasticsearch database.
	 * @param {Object} linkers Map of functions used to generate project links.
	 *
	 * @return {raita.Dashboard}
	 */
	raita.dashboard = function (selector, dbURL, linkers) {
		var dash = new raita.Dashboard(dbURL, linkers);

		function router() {
			dash.route.apply(dash, arguments);
		}

		riot.route(router);
		dash.mount(selector);
		riot.route.exec(router);

		if (location.hash.length === 0) {
			location.hash = '#builds/latest';
		}

		return dash;
	};

	/**
	 * @class
	 *
	 * Interface to an Elasticsearch index.
	 *
	 * @param {String} url URL to the ES index.
	 */
	raita.Database = function (url) {
		this.url = url;
	};

	(function (db) {
		/**
		 * Retrieves the given document from the index.
		 *
		 * @param {String} type Type of ES document to retrieve.
		 * @param {String} id Document ID.
		 */
		db.get = function (type, id) {
			return this.request('get', this.pathTo(type, id));
		};

		/**
		 * Returns a qualified database URL for the given path components.
		 *
		 * @param {String...} paths Path components.
		 *
		 * @return {String}
		 */
		db.pathTo = function () {
			return this.url + '/' + Array.prototype.join.call(arguments, '/');
		};

		/**
		 * Peforms an `application/json` XHR.
		 *
		 * @param {String} method HTTP method.
		 * @param {String} url Request URL.
		 * @param {Object} data Data to be sent in the request body as JSON.
		 */
		db.request = function (method, url, data) {
			var options = { method: method, url: url };

			if (typeof data !== 'undefined') {
				options.data = JSON.stringify(data);
				options.contentType = 'application/json';
			}

			return $.ajax(options);
		};

		/**
		 * Searchs the ES index for documents of the given type that match the
		 * given query.
		 *
		 * @param {String} type Document type.
		 * @param {Object} query Query object.
		 * @param {Array} [fields=['_source']] Document fields to include in the results.
		 */
		db.search = function (type, query, fields) {
			query = $.extend({}, raita.DEFAULT_QUERY, query);
			fields = (fields || [ '_source' ]).join(',');

			return this.request('post', this.pathTo(type, '_search') + '?fields=' + fields, query);
		};

		/**
		 * Maps each of the given query results to its `_source` document, and
		 * includes any objects that were returned in the `fields` property.
		 *
		 * @param {Array} hits ES query hits array.
		 * @param {String} [mapByProperty] Source property by which to index.
		 *
		 * @return {Array/Object}
		 * Either an array or, if `mapByProperty` was specified, an object of
		 * source documents.
		 */
		db.sourcesOf = function (hits, mapByProperty) {
			var sources = mapByProperty ? {} : [];

			for (var i = 0; i < hits.length; i++) {
				var source = hits[i]._source;

				source._id = hits[i]._id;

				if (hits[i].fields) {
					for (var k in hits[i].fields) {
						source[k] = hits[i].fields[k];
					}
				}

				if (mapByProperty) {
					sources[source[mapByProperty]] = sources[source[mapByProperty]] || [];
					sources[source[mapByProperty]].push(source);
				} else {
					sources.push(source);
				}
			}

			return sources;
		};

	})(raita.Database.prototype);

	/**
	 * @class
	 *
	 * Main dashboard controller.
	 *
	 * @param {string} dbURL URL to the Elasticsearch index.
	 * @param {Object} linkers Map of functions used to generate project links.
	 */
	raita.Dashboard = function (dbURL, linkers) {
		this.db = new raita.Database(dbURL);
		$.extend(this.linkers, linkers);
		riot.observable(this);
	};

	(function (dash) {
		/**
		 * @event load-build
		 * Triggered upon loading a build with {@link raita.Dashboard#loadBuild}.
		 *
		 * @param {String} id Build document ID.
		 * @param {Object} build Build document.
		 */

		/**
		 * @event load-builds
		 * Triggered upon loading builds with {@link raita.Dashboard#loadBuilds}.
		 *
		 * @param {Object[]} builds Build documents.
		 */

		/**
		 * @event load-build-features
		 * Triggered upon loading build features with
		 * {@link raita.Dashboard#loadFeatures}.
		 *
		 * @param {Object[]} features Feature documents.
		 */

		/**
		 * @event load-build-features-elements
		 * Triggered upon loading feature elements with
		 * {@link raita.Dashboard#loadElements}.
		 *
		 * @param {Object[]} elements Feature element documents.
		 */

		/**
		 * @property
		 * Functions used to create project related links to the repo, commit,
		 * diffs, etc. This can be overridden when instantiating a
		 * {raita.Dashboard}.
		 */
		dash.linkers = {
			projectPath: function () {
				var parser = document.createElement('a');
				parser.href = this.project.repo;

				return parser.pathname.substr(1).replace(/^r\//, '');
			},

			projectURLComponent: function () {
				return this.projectPath();
			},

			commitURL: function () {
				return 'https://phabricator.wikimedia.org/r/p/' +
					this.projectURLComponent() + ';browse/;' + this.project.commit;
			},

			repoURL: function () {
				return 'https://gerrit.wikimedia.org/r/p/' + this.projectPath();
			}
		};

		/**
		 * Extends the given build object with functions for creating repo,
		 * commit, and diff links.
		 *
		 * @param {Object, Object[]} build Build(s) retrieved from Elasticsearch.
		 *
		 * @return {Object} Object with functions added.
		 */
		dash.build = function (build) {
			var self = this;

			function ext(b) { return $.extend({}, b, self.linkers); }

			return (build instanceof Array) ? build.map(ext) : ext(build);
		};

		/**
		 * Compiles user-provided filter expressions into an Elasticsearch filter.
		 *
		 * @param {String} type Type of document for which to create a filter.
		 * @param {Object[]} ufilter User filter expressions.
		 *
		 * @return {Object} Elasticsearch filter expression.
		 */
		dash.compileUserFilter = function (type, ufilter) {
			var esfilter = { bool: { must: [], should: [] } };

			function relation(filter) {
				if (type === 'feature-element') {
					return { has_parent: { type: 'feature', filter: filter } };
				} else {
					return { has_child: { type: 'feature-element', filter: filter } };
				}
			}

			if (ufilter) {
				for (var i = 0; i < ufilter.length; i++) {
					for (var key in ufilter[i]) {
						var val = ufilter[i][key],
								filter;

						switch (key) {
							case 'tag':
								filter = { nested: { path: 'tags', filter: { term: { 'tags.name': val } } } };

								esfilter.bool.should.push(filter, relation(filter));
								break;
							case 'status':
								filter = { term: { 'result.status': val } };

								esfilter.bool.must.push(type === 'feature' ? relation(filter) : filter);
								break;
						}
					}
				}
			}

			esfilter.bool = this.pruneFilter(esfilter.bool);

			return esfilter;
		};

		/**
		 * Loads the given build, triggering a {@link raita.Dashboard#load-build}
		 * event when it has been loaded.
		 *
		 * @param {String} id Build document ID.
		 */
		dash.loadBuild = function (id) {
			var self = this;

			this.db.get('build', id)
				.done(function (data) {
					self.trigger('load-build', data._id, self.build(data._source));
				});
		};

		/**
		 * Loads the most recent builds, triggering a
		 * {@link raita.Dashboard#load-builds} event when they have been loaded.
		 *
		 * @param {String} project Project name for which to limit the scope.
		 */
		dash.loadBuilds = function (project) {
			var self = this,
					query = { size: 13, sort: [ { _timestamp: { order: 'desc' } } ] };

			self.trigger('loading-builds', project);

			if (typeof project !== 'undefined') {
				query.filter = { term: { "project.repo": project } };
			}

			this.db.search('build', query)
				.done(function (data) {
					if (data.hits.hits.length > 0) {
						self.trigger('load-builds', self.build(self.db.sourcesOf(data.hits.hits)), project);
					}
				});
		};

		/**
		 * Loads feature elements for the given feature document IDs that match the
		 * given user filters, triggering a
		 * {@link raita.Dashboard#load-build-features-elements} event when they
		 * have been loaded.
		 *
		 * @param {String[]} featureIds Feature document IDs.
		 * @param {Object[]} ufilter User filter expressions.
		 */
		dash.loadElements = function (featureIds, ufilter) {
			var self = this;

			var elementFilter = {
				bool: {
					must: { has_parent: { type: 'feature', filter: { ids: { values: featureIds } } } }
				}
			};

			ufilter = this.compileUserFilter('feature-element', ufilter);

			if (Object.keys(ufilter.bool).length > 0) {
				elementFilter.bool.should = [
					{ term: { type: "background" } },
					ufilter
				];
			}

			this.db.search('feature-element', { filter: elementFilter }, [ '_source', '_parent'])
				.done(function (data) {
					self.trigger('load-build-features-elements', self.db.sourcesOf(data.hits.hits, '_parent'));
				});
		};

		/**
		 * Loads features for the given build document ID that match the given
		 * user filters, triggering a {@link raita.Dashboard#load-build-features}
		 * event when they have been loaded.
		 *
		 * @param {String[]} featureIds Feature document IDs.
		 * @param {Object[]} ufilter User filter expressions.
		 */
		dash.loadFeatures = function (buildId, ufilter) {
			var self = this;

			var featureFilter = {
				bool: {
					must: [ { has_parent: { type: 'build', filter: { term: { _id: buildId } } } } ]
				}
			};

			ufilter = this.compileUserFilter('feature', ufilter);

			if (ufilter.bool.must) {
				for (var i = 0; i < ufilter.bool.must.length; i++) {
					featureFilter.bool.must.push(ufilter.bool.must[i]);
				}
			}

			if (ufilter.bool.should) {
				featureFilter.bool.should = ufilter.bool.should;
			}

			this.db.search('feature', { filter: featureFilter })
				.done(function (data) {
					self.trigger('load-build-features', buildId, self.db.sourcesOf(data.hits.hits));
				});
		};

		/**
		 * Loads the latest build, triggering a {@link raita.Dashboard#load-build}
		 * when it has been loaded.
		 *
		 * @param {String} project Optional project by which to filter.
		 */
		dash.loadLatestBuild = function (project) {
			var self = this,
					query = { size: 1, sort: [ { _timestamp: { order: 'desc' } } ] };

			self.trigger('loading-latest-build', project);

			if (typeof project !== 'undefined') {
				query.filter = { term: { "project.repo": project } };
			}

			this.db.search('build', query)
				.done(function (data) {
					if (data.hits.hits.length > 0) {
						var hit = data.hits.hits[0];
						self.trigger('load-build', hit._id, self.build(hit._source));
					}
				});
		};

		/**
		 * Loads projects (inferred by distinct repo URL value in builds), trigging
		 * a {@link raita.Dashboard#load-projects} when they have been loaded.
		 */
		dash.loadProjects = function () {
			var self = this;

			this.db.search('build', { size: 0, aggs: { projects: { terms: { field: "project.repo" } } } })
				.done(function (data) {
					var repos = data.aggregations.projects.buckets.map(function (b) { return b.key; });
					self.trigger('load-projects', self.projectsFromRepos(repos));
				});
		};

		/**
		 * Mounts elements that match the given selector as 'rt-dashbaord'
		 * components.
		 *
		 * @param {String} selector Element selector.
		 */
		dash.mount = function (selector) {
			riot.mount(selector, 'rt-dashboard', this);
		};

		/**
		 * Generates names and IDs for the given project repos. Each ID will be
		 * the path portion of the repo URL, with '/' escaped as ';';
		 *
		 * @param {String[]} repos Project repo URLs.
		 */
		dash.projectsFromRepos = function (repos) {
			return repos.map(function (url) {
				var parser = document.createElement('a'),
						name;

				parser.href = url;
				name = parser.pathname.substr(1).replace(/^r\//, '');

				return { repo: url, name: name, id: name.replace(/\//g, ';') };
			});
		};

		/**
		 * Returns a copy of the given filter with empty properties removed.
		 *
		 * @param {Object} filter Elasticsearch filter expression.
		 */
		dash.pruneFilter = function (filter) {
			var newFilter = {};

			for (var k in filter) {
				if (filter[k].length > 0) {
					newFilter[k] = filter[k];
				}
			}

			return newFilter;
		};

		/**
		 * Dispatches requests for resources.
		 *
		 * @param {String} collection Resource type.
		 * @param {String} id Resource ID.
		 * @param {String} nested Nested resource type.
		 * @param {String} nid Nested resource ID.
		 */
		dash.route = function (collection, id, nested, nid) {
			var self = this;

			function loadBuild(id, project) {
				if (id === 'latest') {
					self.loadLatestBuild(project);
				} else {
					self.loadBuild(id);
				}
			}

			switch (collection) {
				case 'builds':
					self.loadBuilds();
					loadBuild(id);

					break;
				case 'projects':
					id = decodeURIComponent(id);
					self.loadBuilds(id);
					loadBuild((nested === 'builds' && nid) || 'latest', id);

					break;
			}
		};

		/**
		 * Subscribes a given tag to dashboard events. The `mount` and `unmount`
		 * events that Riot tags emit will respectively enable and disable the
		 * subscription.
		 *
		 * @param {riot.Tag} tag Tag that will emit `mount` and `unmount` events.
		 * @param {Object} callbacks Object of dashboard event name/callback pairs.
		 */
		dash.subscribe = function (tag, callbacks) {
			var self = this;

			function sub(onOff) {
				return function () {
					for (var ev in callbacks) {
						self[onOff](ev, callbacks[ev]);
					}
				};
			}

			tag.on('mount', sub('on'));
			tag.on('unmount', sub('off'));
		};

	})(raita.Dashboard.prototype);

	return raita;
});
